#!/usr/bin/env bash

# scenicplus build-main
# 
# This wrapper script is auto-generated by viash 0.8.6 and is thus a derivative
# work thereof. This software comes with ABSOLUTELY NO WARRANTY from Data
# Intuitive.
# 
# The component may contain files which fall under a different license. The
# authors of this component should specify the license in the header of such
# files, or include a separate license file detailing the licenses of all included
# files.

set -e

if [ -z "$VIASH_TEMP" ]; then
  VIASH_TEMP=${VIASH_TEMP:-$VIASH_TMPDIR}
  VIASH_TEMP=${VIASH_TEMP:-$VIASH_TEMPDIR}
  VIASH_TEMP=${VIASH_TEMP:-$VIASH_TMP}
  VIASH_TEMP=${VIASH_TEMP:-$TMPDIR}
  VIASH_TEMP=${VIASH_TEMP:-$TMP}
  VIASH_TEMP=${VIASH_TEMP:-$TEMPDIR}
  VIASH_TEMP=${VIASH_TEMP:-$TEMP}
  VIASH_TEMP=${VIASH_TEMP:-/tmp}
fi

# define helper functions
# ViashQuote: put quotes around non flag values
# $1     : unquoted string
# return : possibly quoted string
# examples:
#   ViashQuote --foo      # returns --foo
#   ViashQuote bar        # returns 'bar'
#   Viashquote --foo=bar  # returns --foo='bar'
function ViashQuote {
  if [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+=.+$ ]]; then
    echo "$1" | sed "s#=\(.*\)#='\1'#"
  elif [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+$ ]]; then
    echo "$1"
  else
    echo "'$1'"
  fi
}
# ViashRemoveFlags: Remove leading flag
# $1     : string with a possible leading flag
# return : string without possible leading flag
# examples:
#   ViashRemoveFlags --foo=bar  # returns bar
function ViashRemoveFlags {
  echo "$1" | sed 's/^--*[a-zA-Z0-9_\-]*=//'
}
# ViashSourceDir: return the path of a bash file, following symlinks
# usage   : ViashSourceDir ${BASH_SOURCE[0]}
# $1      : Should always be set to ${BASH_SOURCE[0]}
# returns : The absolute path of the bash file
function ViashSourceDir {
  SOURCE="$1"
  while [ -h "$SOURCE" ]; do
    DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
  done
  cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd
}
# ViashFindTargetDir: return the path of the '.build.yaml' file, following symlinks
# usage   : ViashFindTargetDir 'ScriptPath'
# $1      : The location from where to start the upward search
# returns : The absolute path of the '.build.yaml' file
function ViashFindTargetDir {
  SOURCE="$1"
  while [[ "$SOURCE" != "" && ! -e "$SOURCE/.build.yaml" ]]; do
    SOURCE=${SOURCE%/*}
  done
  echo $SOURCE
}
# see https://en.wikipedia.org/wiki/Syslog#Severity_level
VIASH_LOGCODE_EMERGENCY=0
VIASH_LOGCODE_ALERT=1
VIASH_LOGCODE_CRITICAL=2
VIASH_LOGCODE_ERROR=3
VIASH_LOGCODE_WARNING=4
VIASH_LOGCODE_NOTICE=5
VIASH_LOGCODE_INFO=6
VIASH_LOGCODE_DEBUG=7
VIASH_VERBOSITY=$VIASH_LOGCODE_NOTICE

# ViashLog: Log events depending on the verbosity level
# usage: ViashLog 1 alert Oh no something went wrong!
# $1: required verbosity level
# $2: display tag
# $3+: messages to display
# stdout: Your input, prepended by '[$2] '.
function ViashLog {
  local required_level="$1"
  local display_tag="$2"
  shift 2
  if [ $VIASH_VERBOSITY -ge $required_level ]; then
    >&2 echo "[$display_tag]" "$@"
  fi
}

# ViashEmergency: log events when the system is unstable
# usage: ViashEmergency Oh no something went wrong.
# stdout: Your input, prepended by '[emergency] '.
function ViashEmergency {
  ViashLog $VIASH_LOGCODE_EMERGENCY emergency "$@"
}

# ViashAlert: log events when actions must be taken immediately (e.g. corrupted system database)
# usage: ViashAlert Oh no something went wrong.
# stdout: Your input, prepended by '[alert] '.
function ViashAlert {
  ViashLog $VIASH_LOGCODE_ALERT alert "$@"
}

# ViashCritical: log events when a critical condition occurs
# usage: ViashCritical Oh no something went wrong.
# stdout: Your input, prepended by '[critical] '.
function ViashCritical {
  ViashLog $VIASH_LOGCODE_CRITICAL critical "$@"
}

# ViashError: log events when an error condition occurs
# usage: ViashError Oh no something went wrong.
# stdout: Your input, prepended by '[error] '.
function ViashError {
  ViashLog $VIASH_LOGCODE_ERROR error "$@"
}

# ViashWarning: log potentially abnormal events
# usage: ViashWarning Something may have gone wrong.
# stdout: Your input, prepended by '[warning] '.
function ViashWarning {
  ViashLog $VIASH_LOGCODE_WARNING warning "$@"
}

# ViashNotice: log significant but normal events
# usage: ViashNotice This just happened.
# stdout: Your input, prepended by '[notice] '.
function ViashNotice {
  ViashLog $VIASH_LOGCODE_NOTICE notice "$@"
}

# ViashInfo: log normal events
# usage: ViashInfo This just happened.
# stdout: Your input, prepended by '[info] '.
function ViashInfo {
  ViashLog $VIASH_LOGCODE_INFO info "$@"
}

# ViashDebug: log all events, for debugging purposes
# usage: ViashDebug This just happened.
# stdout: Your input, prepended by '[debug] '.
function ViashDebug {
  ViashLog $VIASH_LOGCODE_DEBUG debug "$@"
}

# find source folder of this component
VIASH_META_RESOURCES_DIR=`ViashSourceDir ${BASH_SOURCE[0]}`

# find the root of the built components & dependencies
VIASH_TARGET_DIR=`ViashFindTargetDir $VIASH_META_RESOURCES_DIR`

# define meta fields
VIASH_META_FUNCTIONALITY_NAME="scenicplus"
VIASH_META_EXECUTABLE="$VIASH_META_RESOURCES_DIR/$VIASH_META_FUNCTIONALITY_NAME"
VIASH_META_CONFIG="$VIASH_META_RESOURCES_DIR/.config.vsh.yaml"
VIASH_META_TEMP_DIR="$VIASH_TEMP"


# ViashHelp: Display helpful explanation about this executable
function ViashHelp {
  echo "scenicplus build-main"
  echo ""
  echo "Arguments:"
  echo "    --multiomics_rna"
  echo "        type: file, required parameter, file must exist"
  echo "        example: resources_test/grn-benchmark/multiomics_rna.h5ad"
  echo ""
  echo "    --multiomics_atac"
  echo "        type: file, file must exist"
  echo "        example: resources_test/grn-benchmark/multiomics_atac.h5ad"
  echo ""
  echo "    --prediction"
  echo "        type: file, output, file must exist"
  echo "        example: resources_test/grn_models/collectri.csv"
  echo ""
  echo "    --tf_all"
  echo "        type: file, required parameter, file must exist"
  echo "        example: resources_test/prior/tf_all.csv"
  echo ""
  echo "    --max_n_links"
  echo "        type: integer"
  echo "        default: 50000"
  echo ""
  echo "    --num_workers"
  echo "        type: integer"
  echo "        default: 4"
  echo ""
  echo "    --temp_dir"
  echo "        type: string"
  echo "        default: output/temdir"
  echo ""
  echo "    --seed"
  echo "        type: integer"
  echo "        default: 32"
  echo ""
  echo "    --cell_type_specific"
  echo "        type: boolean"
  echo "        default: false"
  echo ""
  echo "    --normalize"
  echo "        type: boolean"
  echo "        default: false"
  echo "        normalize rna seq data before inference. currently, it's only applicable"
  echo "        to baseline models"
  echo ""
  echo "    --only_hvgs"
  echo "        type: boolean"
  echo "        default: false"
  echo "        subset rna seq data to only 7000 hvgs to reduce dimensionality"
  echo ""
  echo "    --scplus_mdata"
  echo "        type: file, output, file must exist"
  echo "        default: scplus_mdata.h5mu"
  echo "        Main output object."
  echo ""
  echo "    --qc"
  echo "        type: boolean"
  echo "        default: false"
  echo "        Whether to perform quality control."
  echo ""
  echo "    --cell_topic"
  echo "        type: file, output, file must exist"
  echo "        default: output/cell_topic.csv"
  echo "        Cell-topics prob scores"
  echo ""
  echo "    --grn_extended"
  echo "        type: file, output, file must exist"
  echo "        default: output/grn_extended.csv"
  echo "        Source-target-peak triplets"
}

######## Helper functions for setting up Docker images for viash ########
# expects: ViashDockerBuild

# ViashDockerInstallationCheck: check whether Docker is installed correctly
#
# examples:
#   ViashDockerInstallationCheck
function ViashDockerInstallationCheck {
  ViashDebug "Checking whether Docker is installed"
  if [ ! command -v docker &> /dev/null ]; then
    ViashCritical "Docker doesn't seem to be installed. See 'https://docs.docker.com/get-docker/' for instructions."
    exit 1
  fi

  ViashDebug "Checking whether the Docker daemon is running"
  save=$-; set +e
  docker_version=$(docker version --format '{{.Client.APIVersion}}' 2> /dev/null)
  out=$?
  [[ $save =~ e ]] && set -e
  if [ $out -ne 0 ]; then
    ViashCritical "Docker daemon does not seem to be running. Try one of the following:"
    ViashCritical "- Try running 'dockerd' in the command line"
    ViashCritical "- See https://docs.docker.com/config/daemon/"
    exit 1
  fi
}

# ViashDockerRemoteTagCheck: check whether a Docker image is available 
# on a remote. Assumes `docker login` has been performed, if relevant.
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# exit code $?        : whether or not the image was found
# examples:
#   ViashDockerRemoteTagCheck python:latest
#   echo $?                                     # returns '0'
#   ViashDockerRemoteTagCheck sdaizudceahifu
#   echo $?                                     # returns '1'
function ViashDockerRemoteTagCheck {
  docker manifest inspect $1 > /dev/null 2> /dev/null
}

# ViashDockerLocalTagCheck: check whether a Docker image is available locally
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# exit code $?        : whether or not the image was found
# examples:
#   docker pull python:latest
#   ViashDockerLocalTagCheck python:latest
#   echo $?                                     # returns '0'
#   ViashDockerLocalTagCheck sdaizudceahifu
#   echo $?                                     # returns '1'
function ViashDockerLocalTagCheck {
  [ -n "$(docker images -q $1)" ]
}

# ViashDockerPull: pull a Docker image
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# exit code $?        : whether or not the image was found
# examples:
#   ViashDockerPull python:latest
#   echo $?                                     # returns '0'
#   ViashDockerPull sdaizudceahifu
#   echo $?                                     # returns '1'
function ViashDockerPull {
  ViashNotice "Checking if Docker image is available at '$1'"
  if [ $VIASH_VERBOSITY -ge $VIASH_LOGCODE_INFO ]; then
    docker pull $1 && return 0 || return 1
  else
    save=$-; set +e
    docker pull $1 2> /dev/null > /dev/null
    out=$?
    [[ $save =~ e ]] && set -e
    if [ $out -ne 0 ]; then
      ViashWarning "Could not pull from '$1'. Docker image doesn't exist or is not accessible."
    fi
    return $out
  fi
}

# ViashDockerPush: push a Docker image
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# exit code $?        : whether or not the image was found
# examples:
#   ViashDockerPush python:latest
#   echo $?                                     # returns '0'
#   ViashDockerPush sdaizudceahifu
#   echo $?                                     # returns '1'
function ViashDockerPush {
  ViashNotice "Pushing image to '$1'"
  save=$-; set +e
  if [ $VIASH_VERBOSITY -ge $VIASH_LOGCODE_INFO ]; then
    docker push $1
    out=$?
  else
    docker push $1 2> /dev/null > /dev/null
    out=$?
  fi
  [[ $save =~ e ]] && set -e
  if [ $out -eq 0 ]; then
    ViashNotice "Container '$VSHD_ID' push succeeded."
  else
    ViashError "Container '$VSHD_ID' push errored. You might not be logged in or have the necessary permissions."
  fi
  return $out
}

# ViashDockerPullElseBuild: pull a Docker image, else build it
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# ViashDockerBuild    : a Bash function which builds a docker image, takes image identifier as argument.
# examples:
#   ViashDockerPullElseBuild mynewcomponent
function ViashDockerPullElseBuild {
  save=$-; set +e
  ViashDockerPull $1
  out=$?
  [[ $save =~ e ]] && set -e
  if [ $out -ne 0 ]; then
    ViashDockerBuild $@
  fi
}

# ViashDockerSetup: create a Docker image, according to specified docker setup strategy
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# $2                  : docker setup strategy, see DockerSetupStrategy.scala
# ViashDockerBuild    : a Bash function which builds a docker image, takes image identifier as argument.
# examples:
#   ViashDockerSetup mynewcomponent alwaysbuild
function ViashDockerSetup {
  VSHD_ID="$1"
  VSHD_STRAT="$2"
  if [ "$VSHD_STRAT" == "alwaysbuild" -o "$VSHD_STRAT" == "build" -o "$VSHD_STRAT" == "b" ]; then
    ViashDockerBuild $VSHD_ID --no-cache
  elif [ "$VSHD_STRAT" == "alwayspull" -o "$VSHD_STRAT" == "pull" -o "$VSHD_STRAT" == "p" ]; then
    ViashDockerPull $VSHD_ID
  elif [ "$VSHD_STRAT" == "alwayspullelsebuild" -o "$VSHD_STRAT" == "pullelsebuild" ]; then
    ViashDockerPullElseBuild $VSHD_ID --no-cache
  elif [ "$VSHD_STRAT" == "alwayspullelsecachedbuild" -o "$VSHD_STRAT" == "pullelsecachedbuild" ]; then
    ViashDockerPullElseBuild $VSHD_ID
  elif [ "$VSHD_STRAT" == "alwayscachedbuild" -o "$VSHD_STRAT" == "cachedbuild" -o "$VSHD_STRAT" == "cb" ]; then
    ViashDockerBuild $VSHD_ID
  elif [[ "$VSHD_STRAT" =~ ^ifneedbe ]]; then
    save=$-; set +e
    ViashDockerLocalTagCheck $VSHD_ID
    outCheck=$?
    [[ $save =~ e ]] && set -e
    if [ $outCheck -eq 0 ]; then
      ViashInfo "Image $VSHD_ID already exists"
    elif [ "$VSHD_STRAT" == "ifneedbebuild" ]; then
      ViashDockerBuild $VSHD_ID --no-cache
    elif [ "$VSHD_STRAT" == "ifneedbecachedbuild" ]; then
      ViashDockerBuild $VSHD_ID
    elif [ "$VSHD_STRAT" == "ifneedbepull" ]; then
      ViashDockerPull $VSHD_ID
    elif [ "$VSHD_STRAT" == "ifneedbepullelsebuild" ]; then
      ViashDockerPullElseBuild $VSHD_ID --no-cache
    elif [ "$VSHD_STRAT" == "ifneedbepullelsecachedbuild" ]; then
      ViashDockerPullElseBuild $VSHD_ID
    else
      ViashError "Unrecognised Docker strategy: $VSHD_STRAT"
      exit 1
    fi
  elif [ "$VSHD_STRAT" == "push" -o "$VSHD_STRAT" == "forcepush" -o "$VSHD_STRAT" == "alwayspush" ]; then
    ViashDockerPush "$VSHD_ID"
  elif [ "$VSHD_STRAT" == "pushifnotpresent" -o "$VSHD_STRAT" == "gentlepush" -o "$VSHD_STRAT" == "maybepush" ]; then
    save=$-; set +e
    ViashDockerRemoteTagCheck $VSHD_ID
    outCheck=$?
    [[ $save =~ e ]] && set -e
    if [ $outCheck -eq 0 ]; then
      ViashNotice "Container '$VSHD_ID' exists, doing nothing."
    else
      ViashNotice "Container '$VSHD_ID' does not yet exist."
      ViashDockerPush "$VSHD_ID"
    fi
  elif [ "$VSHD_STRAT" == "donothing" -o "$VSHD_STRAT" == "meh" ]; then
    ViashNotice "Skipping setup."
  else
    ViashError "Unrecognised Docker strategy: $VSHD_STRAT"
    exit 1
  fi
}

# ViashDockerCheckCommands: Check whether a docker container has the required commands
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# $@                  : commands to verify being present
# examples:
#   ViashDockerCheckCommands bash:4.0 bash ps foo
function ViashDockerCheckCommands {
  tag=$1
  shift 1
  commands="$@"
  save=$-; set +e
  missing=$(docker run --rm --entrypoint=sh $tag -c "for command in $commands; do command -v \$command >/dev/null 2>&1; if [ \$? -ne 0 ]; then echo \$command; exit 1; fi; done")
  outCheck=$?
  [[ $save =~ e ]] && set -e
  if [ $outCheck -ne 0 ]; then
  	ViashError "Docker container '$tag' does not contain command '$missing'."
  	exit 1
  fi
}


######## End of helper functions for setting up Docker images for viash ########

# ViashDockerFile: print the dockerfile to stdout
# return : dockerfile required to run this component
# examples:
#   ViashDockerFile
function ViashDockerfile {
  cat << 'VIASHDOCKER'
FROM aertslab/pyscenic:0.12.1

ENTRYPOINT []

 
RUN :
LABEL org.opencontainers.image.description="Companion container for running component grn_methods scenicplus"
LABEL org.opencontainers.image.created="2024-09-23T15:15:43Z"
LABEL org.opencontainers.image.source="https://github.com/openproblems-bio/task_grn_inference"
LABEL org.opencontainers.image.revision="347b16044d81f1609b1091b1ca2c5543a4037777"
LABEL org.opencontainers.image.version="build-main"

VIASHDOCKER
}

# ViashDockerBuild: build a docker container
# $1              : image identifier with format `[registry/]image[:tag]`
# exit code $?    : whether or not the image was built
function ViashDockerBuild {
  # create temporary directory to store dockerfile & optional resources in
  tmpdir=$(mktemp -d "$VIASH_META_TEMP_DIR/dockerbuild-scenicplus-XXXXXX")
  dockerfile="$tmpdir/Dockerfile"
  function clean_up {
    rm -rf "$tmpdir"
  }
  trap clean_up EXIT

  # store dockerfile and resources
  ViashDockerfile > $dockerfile

  # Build the container
  ViashNotice "Building container '$1' with Dockerfile"
  ViashInfo "Running 'docker build -t $@ $VIASH_META_RESOURCES_DIR -f $dockerfile'"
  save=$-; set +e
  if [ $VIASH_VERBOSITY -ge $VIASH_LOGCODE_INFO ]; then
    docker build -t $@ $VIASH_META_RESOURCES_DIR -f $dockerfile
  else
    docker build -t $@ $VIASH_META_RESOURCES_DIR -f $dockerfile &> $tmpdir/docker_build.log
  fi
  out=$?
  [[ $save =~ e ]] && set -e
  if [ $out -ne 0 ]; then
    ViashError "Error occurred while building container '$1'"
    if [ $VIASH_VERBOSITY -lt $VIASH_LOGCODE_INFO ]; then
      ViashError "Transcript: --------------------------------"
      cat "$tmpdir/docker_build.log"
      ViashError "End of transcript --------------------------"
    fi
    exit 1
  fi
  ViashDockerCheckCommands "$1" 'bash'
}

# ViashAbsolutePath: generate absolute path from relative path
# borrowed from https://stackoverflow.com/a/21951256
# $1     : relative filename
# return : absolute path
# examples:
#   ViashAbsolutePath some_file.txt   # returns /path/to/some_file.txt
#   ViashAbsolutePath /foo/bar/..     # returns /foo
function ViashAbsolutePath {
  local thePath
  if [[ ! "$1" =~ ^/ ]]; then
    thePath="$PWD/$1"
  else
    thePath="$1"
  fi
  echo "$thePath" | (
    IFS=/
    read -a parr
    declare -a outp
    for i in "${parr[@]}"; do
      case "$i" in
      ''|.) continue ;;
      ..)
        len=${#outp[@]}
        if ((len==0)); then
          continue
        else
          unset outp[$((len-1))]
        fi
        ;;
      *)
        len=${#outp[@]}
        outp[$len]="$i"
      ;;
      esac
    done
    echo /"${outp[*]}"
  )
}
# ViashAutodetectMount: auto configuring docker mounts from parameters
# $1                  : The parameter value
# returns             : New parameter
# $VIASH_EXTRA_MOUNTS : Added another parameter to be passed to docker
# examples:
#   ViashAutodetectMount /path/to/bar      # returns '/viash_automount/path/to/bar'
#   ViashAutodetectMountArg /path/to/bar   # returns '--volume="/path/to:/viash_automount/path/to"'
function ViashAutodetectMount {
  abs_path=$(ViashAbsolutePath "$1")
  if [ -d "$abs_path" ]; then
    mount_source="$abs_path"
    base_name=""
  else
    mount_source=`dirname "$abs_path"`
    base_name=`basename "$abs_path"`
  fi
  mount_target="/viash_automount$mount_source"
  if [ -z "$base_name" ]; then
    echo "$mount_target"
  else
    echo "$mount_target/$base_name"
  fi
}
function ViashAutodetectMountArg {
  abs_path=$(ViashAbsolutePath "$1")
  if [ -d "$abs_path" ]; then
    mount_source="$abs_path"
    base_name=""
  else
    mount_source=`dirname "$abs_path"`
    base_name=`basename "$abs_path"`
  fi
  mount_target="/viash_automount$mount_source"
  ViashDebug "ViashAutodetectMountArg $1 -> $mount_source -> $mount_target"
  echo "--volume=\"$mount_source:$mount_target\""
}
function ViashStripAutomount {
  abs_path=$(ViashAbsolutePath "$1")
  echo "${abs_path#/viash_automount}"
}
# ViashExtractFlags: Retain leading flag
# $1     : string with a possible leading flag
# return : leading flag
# examples:
#   ViashExtractFlags --foo=bar  # returns --foo
function ViashExtractFlags {
  echo $1 | sed 's/=.*//'
}
# initialise variables
VIASH_EXTRA_MOUNTS=()

# initialise array
VIASH_POSITIONAL_ARGS=''
VIASH_MODE='run'

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            ViashHelp
            exit
            ;;
        ---v|---verbose)
            let "VIASH_VERBOSITY=VIASH_VERBOSITY+1"
            shift 1
            ;;
        ---verbosity)
            VIASH_VERBOSITY="$2"
            shift 2
            ;;
        ---verbosity=*)
            VIASH_VERBOSITY="$(ViashRemoveFlags "$1")"
            shift 1
            ;;
        --version)
            echo "scenicplus build-main"
            exit
            ;;
        --multiomics_rna)
            [ -n "$VIASH_PAR_MULTIOMICS_RNA" ] && ViashError Bad arguments for option \'--multiomics_rna\': \'$VIASH_PAR_MULTIOMICS_RNA\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_MULTIOMICS_RNA="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --multiomics_rna. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --multiomics_rna=*)
            [ -n "$VIASH_PAR_MULTIOMICS_RNA" ] && ViashError Bad arguments for option \'--multiomics_rna=*\': \'$VIASH_PAR_MULTIOMICS_RNA\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_MULTIOMICS_RNA=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --multiomics_atac)
            [ -n "$VIASH_PAR_MULTIOMICS_ATAC" ] && ViashError Bad arguments for option \'--multiomics_atac\': \'$VIASH_PAR_MULTIOMICS_ATAC\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_MULTIOMICS_ATAC="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --multiomics_atac. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --multiomics_atac=*)
            [ -n "$VIASH_PAR_MULTIOMICS_ATAC" ] && ViashError Bad arguments for option \'--multiomics_atac=*\': \'$VIASH_PAR_MULTIOMICS_ATAC\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_MULTIOMICS_ATAC=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --prediction)
            [ -n "$VIASH_PAR_PREDICTION" ] && ViashError Bad arguments for option \'--prediction\': \'$VIASH_PAR_PREDICTION\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_PREDICTION="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --prediction. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --prediction=*)
            [ -n "$VIASH_PAR_PREDICTION" ] && ViashError Bad arguments for option \'--prediction=*\': \'$VIASH_PAR_PREDICTION\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_PREDICTION=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --tf_all)
            [ -n "$VIASH_PAR_TF_ALL" ] && ViashError Bad arguments for option \'--tf_all\': \'$VIASH_PAR_TF_ALL\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_TF_ALL="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --tf_all. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --tf_all=*)
            [ -n "$VIASH_PAR_TF_ALL" ] && ViashError Bad arguments for option \'--tf_all=*\': \'$VIASH_PAR_TF_ALL\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_TF_ALL=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --max_n_links)
            [ -n "$VIASH_PAR_MAX_N_LINKS" ] && ViashError Bad arguments for option \'--max_n_links\': \'$VIASH_PAR_MAX_N_LINKS\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_MAX_N_LINKS="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --max_n_links. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --max_n_links=*)
            [ -n "$VIASH_PAR_MAX_N_LINKS" ] && ViashError Bad arguments for option \'--max_n_links=*\': \'$VIASH_PAR_MAX_N_LINKS\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_MAX_N_LINKS=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --num_workers)
            [ -n "$VIASH_PAR_NUM_WORKERS" ] && ViashError Bad arguments for option \'--num_workers\': \'$VIASH_PAR_NUM_WORKERS\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_NUM_WORKERS="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --num_workers. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --num_workers=*)
            [ -n "$VIASH_PAR_NUM_WORKERS" ] && ViashError Bad arguments for option \'--num_workers=*\': \'$VIASH_PAR_NUM_WORKERS\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_NUM_WORKERS=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --temp_dir)
            [ -n "$VIASH_PAR_TEMP_DIR" ] && ViashError Bad arguments for option \'--temp_dir\': \'$VIASH_PAR_TEMP_DIR\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_TEMP_DIR="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --temp_dir. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --temp_dir=*)
            [ -n "$VIASH_PAR_TEMP_DIR" ] && ViashError Bad arguments for option \'--temp_dir=*\': \'$VIASH_PAR_TEMP_DIR\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_TEMP_DIR=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --seed)
            [ -n "$VIASH_PAR_SEED" ] && ViashError Bad arguments for option \'--seed\': \'$VIASH_PAR_SEED\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_SEED="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --seed. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --seed=*)
            [ -n "$VIASH_PAR_SEED" ] && ViashError Bad arguments for option \'--seed=*\': \'$VIASH_PAR_SEED\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_SEED=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --cell_type_specific)
            [ -n "$VIASH_PAR_CELL_TYPE_SPECIFIC" ] && ViashError Bad arguments for option \'--cell_type_specific\': \'$VIASH_PAR_CELL_TYPE_SPECIFIC\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_CELL_TYPE_SPECIFIC="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --cell_type_specific. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --cell_type_specific=*)
            [ -n "$VIASH_PAR_CELL_TYPE_SPECIFIC" ] && ViashError Bad arguments for option \'--cell_type_specific=*\': \'$VIASH_PAR_CELL_TYPE_SPECIFIC\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_CELL_TYPE_SPECIFIC=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --normalize)
            [ -n "$VIASH_PAR_NORMALIZE" ] && ViashError Bad arguments for option \'--normalize\': \'$VIASH_PAR_NORMALIZE\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_NORMALIZE="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --normalize. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --normalize=*)
            [ -n "$VIASH_PAR_NORMALIZE" ] && ViashError Bad arguments for option \'--normalize=*\': \'$VIASH_PAR_NORMALIZE\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_NORMALIZE=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --only_hvgs)
            [ -n "$VIASH_PAR_ONLY_HVGS" ] && ViashError Bad arguments for option \'--only_hvgs\': \'$VIASH_PAR_ONLY_HVGS\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_ONLY_HVGS="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --only_hvgs. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --only_hvgs=*)
            [ -n "$VIASH_PAR_ONLY_HVGS" ] && ViashError Bad arguments for option \'--only_hvgs=*\': \'$VIASH_PAR_ONLY_HVGS\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_ONLY_HVGS=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --scplus_mdata)
            [ -n "$VIASH_PAR_SCPLUS_MDATA" ] && ViashError Bad arguments for option \'--scplus_mdata\': \'$VIASH_PAR_SCPLUS_MDATA\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_SCPLUS_MDATA="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --scplus_mdata. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --scplus_mdata=*)
            [ -n "$VIASH_PAR_SCPLUS_MDATA" ] && ViashError Bad arguments for option \'--scplus_mdata=*\': \'$VIASH_PAR_SCPLUS_MDATA\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_SCPLUS_MDATA=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --qc)
            [ -n "$VIASH_PAR_QC" ] && ViashError Bad arguments for option \'--qc\': \'$VIASH_PAR_QC\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_QC="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --qc. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --qc=*)
            [ -n "$VIASH_PAR_QC" ] && ViashError Bad arguments for option \'--qc=*\': \'$VIASH_PAR_QC\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_QC=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --cell_topic)
            [ -n "$VIASH_PAR_CELL_TOPIC" ] && ViashError Bad arguments for option \'--cell_topic\': \'$VIASH_PAR_CELL_TOPIC\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_CELL_TOPIC="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --cell_topic. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --cell_topic=*)
            [ -n "$VIASH_PAR_CELL_TOPIC" ] && ViashError Bad arguments for option \'--cell_topic=*\': \'$VIASH_PAR_CELL_TOPIC\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_CELL_TOPIC=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --grn_extended)
            [ -n "$VIASH_PAR_GRN_EXTENDED" ] && ViashError Bad arguments for option \'--grn_extended\': \'$VIASH_PAR_GRN_EXTENDED\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_GRN_EXTENDED="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --grn_extended. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --grn_extended=*)
            [ -n "$VIASH_PAR_GRN_EXTENDED" ] && ViashError Bad arguments for option \'--grn_extended=*\': \'$VIASH_PAR_GRN_EXTENDED\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_GRN_EXTENDED=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        ---setup)
            VIASH_MODE='docker_setup'
            VIASH_DOCKER_SETUP_STRATEGY="$2"
            shift 1
            ;;
        ---setup=*)
            VIASH_MODE='docker_setup'
            VIASH_DOCKER_SETUP_STRATEGY="$(ViashRemoveFlags "$1")"
            shift 2
            ;;
        ---dockerfile)
            ViashDockerfile
            exit 0
            ;;
        ---v|---volume)
            VIASH_EXTRA_MOUNTS+=("--volume='$2'")
            shift 2
            ;;
        ---volume=*)
            VIASH_EXTRA_MOUNTS+=("--volume='$(ViashRemoveFlags "$2")'")
            shift 1
            ;;
        ---debug)
            VIASH_MODE='docker_debug'
            shift 1
            ;;
        ---cpus)
            [ -n "$VIASH_META_CPUS" ] && ViashError Bad arguments for option \'---cpus\': \'$VIASH_META_CPUS\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_META_CPUS="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to ---cpus. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        ---cpus=*)
            [ -n "$VIASH_META_CPUS" ] && ViashError Bad arguments for option \'---cpus=*\': \'$VIASH_META_CPUS\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_META_CPUS=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        ---memory)
            [ -n "$VIASH_META_MEMORY" ] && ViashError Bad arguments for option \'---memory\': \'$VIASH_META_MEMORY\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_META_MEMORY="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to ---memory. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        ---memory=*)
            [ -n "$VIASH_META_MEMORY" ] && ViashError Bad arguments for option \'---memory=*\': \'$VIASH_META_MEMORY\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_META_MEMORY=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        *)  # positional arg or unknown option
            # since the positional args will be eval'd, can we always quote, instead of using ViashQuote
            VIASH_POSITIONAL_ARGS="$VIASH_POSITIONAL_ARGS '$1'"
            [[ $1 == -* ]] && ViashWarning $1 looks like a parameter but is not a defined parameter and will instead be treated as a positional argument. Use "--help" to get more information on the parameters.
            shift # past argument
            ;;
    esac
done

# parse positional parameters
eval set -- $VIASH_POSITIONAL_ARGS


ViashDockerInstallationCheck

if [ $VIASH_MODE == "docker_setup" ]; then
  ViashDockerSetup 'ghcr.io/openproblems-bio/task_grn_inference/grn_methods/scenicplus:build-main' "$VIASH_DOCKER_SETUP_STRATEGY"
  exit 0
fi
ViashDockerSetup 'ghcr.io/openproblems-bio/task_grn_inference/grn_methods/scenicplus:build-main' ifneedbepullelsecachedbuild

if [ $VIASH_MODE == "docker_debug" ]; then
  ViashNotice "+ docker run --entrypoint=bash -i --rm -v "$(pwd)":/pwd --workdir /pwd -t 'ghcr.io/openproblems-bio/task_grn_inference/grn_methods/scenicplus:build-main'"
  docker run --entrypoint=bash -i --rm -v "$(pwd)":/pwd --workdir /pwd -t 'ghcr.io/openproblems-bio/task_grn_inference/grn_methods/scenicplus:build-main'
  exit 0
fi

# setting computational defaults

# helper function for parsing memory strings
function ViashMemoryAsBytes {
  local memory=`echo "$1" | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]'`
  local memory_regex='^([0-9]+)([kmgtp]b?|b)$'
  if [[ $memory =~ $memory_regex ]]; then
    local number=${memory/[^0-9]*/}
    local symbol=${memory/*[0-9]/}
    
    case $symbol in
      b)      memory_b=$number ;;
      kb|k)   memory_b=$(( $number * 1024 )) ;;
      mb|m)   memory_b=$(( $number * 1024 * 1024 )) ;;
      gb|g)   memory_b=$(( $number * 1024 * 1024 * 1024 )) ;;
      tb|t)   memory_b=$(( $number * 1024 * 1024 * 1024 * 1024 )) ;;
      pb|p)   memory_b=$(( $number * 1024 * 1024 * 1024 * 1024 * 1024 )) ;;
    esac
    echo "$memory_b"
  fi
}
# compute memory in different units
if [ ! -z ${VIASH_META_MEMORY+x} ]; then
  VIASH_META_MEMORY_B=`ViashMemoryAsBytes $VIASH_META_MEMORY`
  # do not define other variables if memory_b is an empty string
  if [ ! -z "$VIASH_META_MEMORY_B" ]; then
    VIASH_META_MEMORY_KB=$(( ($VIASH_META_MEMORY_B+1023) / 1024 ))
    VIASH_META_MEMORY_MB=$(( ($VIASH_META_MEMORY_KB+1023) / 1024 ))
    VIASH_META_MEMORY_GB=$(( ($VIASH_META_MEMORY_MB+1023) / 1024 ))
    VIASH_META_MEMORY_TB=$(( ($VIASH_META_MEMORY_GB+1023) / 1024 ))
    VIASH_META_MEMORY_PB=$(( ($VIASH_META_MEMORY_TB+1023) / 1024 ))
  else
    # unset memory if string is empty
    unset $VIASH_META_MEMORY_B
  fi
fi
# unset nproc if string is empty
if [ -z "$VIASH_META_CPUS" ]; then
  unset $VIASH_META_CPUS
fi


# check whether required parameters exist
if [ -z ${VIASH_PAR_MULTIOMICS_RNA+x} ]; then
  ViashError '--multiomics_rna' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_PAR_TF_ALL+x} ]; then
  ViashError '--tf_all' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_META_FUNCTIONALITY_NAME+x} ]; then
  ViashError 'functionality_name' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_META_RESOURCES_DIR+x} ]; then
  ViashError 'resources_dir' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_META_EXECUTABLE+x} ]; then
  ViashError 'executable' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_META_CONFIG+x} ]; then
  ViashError 'config' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_META_TEMP_DIR+x} ]; then
  ViashError 'temp_dir' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi

# filling in defaults
if [ -z ${VIASH_PAR_MAX_N_LINKS+x} ]; then
  VIASH_PAR_MAX_N_LINKS="50000"
fi
if [ -z ${VIASH_PAR_NUM_WORKERS+x} ]; then
  VIASH_PAR_NUM_WORKERS="4"
fi
if [ -z ${VIASH_PAR_TEMP_DIR+x} ]; then
  VIASH_PAR_TEMP_DIR="output/temdir"
fi
if [ -z ${VIASH_PAR_SEED+x} ]; then
  VIASH_PAR_SEED="32"
fi
if [ -z ${VIASH_PAR_CELL_TYPE_SPECIFIC+x} ]; then
  VIASH_PAR_CELL_TYPE_SPECIFIC="false"
fi
if [ -z ${VIASH_PAR_NORMALIZE+x} ]; then
  VIASH_PAR_NORMALIZE="false"
fi
if [ -z ${VIASH_PAR_ONLY_HVGS+x} ]; then
  VIASH_PAR_ONLY_HVGS="false"
fi
if [ -z ${VIASH_PAR_SCPLUS_MDATA+x} ]; then
  VIASH_PAR_SCPLUS_MDATA="scplus_mdata.h5mu"
fi
if [ -z ${VIASH_PAR_QC+x} ]; then
  VIASH_PAR_QC="false"
fi
if [ -z ${VIASH_PAR_CELL_TOPIC+x} ]; then
  VIASH_PAR_CELL_TOPIC="output/cell_topic.csv"
fi
if [ -z ${VIASH_PAR_GRN_EXTENDED+x} ]; then
  VIASH_PAR_GRN_EXTENDED="output/grn_extended.csv"
fi

# check whether required files exist
if [ ! -z "$VIASH_PAR_MULTIOMICS_RNA" ] && [ ! -e "$VIASH_PAR_MULTIOMICS_RNA" ]; then
  ViashError "Input file '$VIASH_PAR_MULTIOMICS_RNA' does not exist."
  exit 1
fi
if [ ! -z "$VIASH_PAR_MULTIOMICS_ATAC" ] && [ ! -e "$VIASH_PAR_MULTIOMICS_ATAC" ]; then
  ViashError "Input file '$VIASH_PAR_MULTIOMICS_ATAC' does not exist."
  exit 1
fi
if [ ! -z "$VIASH_PAR_TF_ALL" ] && [ ! -e "$VIASH_PAR_TF_ALL" ]; then
  ViashError "Input file '$VIASH_PAR_TF_ALL' does not exist."
  exit 1
fi

# check whether parameters values are of the right type
if [[ -n "$VIASH_PAR_MAX_N_LINKS" ]]; then
  if ! [[ "$VIASH_PAR_MAX_N_LINKS" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError '--max_n_links' has to be an integer. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_PAR_NUM_WORKERS" ]]; then
  if ! [[ "$VIASH_PAR_NUM_WORKERS" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError '--num_workers' has to be an integer. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_PAR_SEED" ]]; then
  if ! [[ "$VIASH_PAR_SEED" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError '--seed' has to be an integer. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_PAR_CELL_TYPE_SPECIFIC" ]]; then
  if ! [[ "$VIASH_PAR_CELL_TYPE_SPECIFIC" =~ ^(true|True|TRUE|false|False|FALSE|yes|Yes|YES|no|No|NO)$ ]]; then
    ViashError '--cell_type_specific' has to be a boolean. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_PAR_NORMALIZE" ]]; then
  if ! [[ "$VIASH_PAR_NORMALIZE" =~ ^(true|True|TRUE|false|False|FALSE|yes|Yes|YES|no|No|NO)$ ]]; then
    ViashError '--normalize' has to be a boolean. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_PAR_ONLY_HVGS" ]]; then
  if ! [[ "$VIASH_PAR_ONLY_HVGS" =~ ^(true|True|TRUE|false|False|FALSE|yes|Yes|YES|no|No|NO)$ ]]; then
    ViashError '--only_hvgs' has to be a boolean. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_PAR_QC" ]]; then
  if ! [[ "$VIASH_PAR_QC" =~ ^(true|True|TRUE|false|False|FALSE|yes|Yes|YES|no|No|NO)$ ]]; then
    ViashError '--qc' has to be a boolean. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_CPUS" ]]; then
  if ! [[ "$VIASH_META_CPUS" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'cpus' has to be an integer. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_MEMORY_B" ]]; then
  if ! [[ "$VIASH_META_MEMORY_B" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'memory_b' has to be a long. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_MEMORY_KB" ]]; then
  if ! [[ "$VIASH_META_MEMORY_KB" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'memory_kb' has to be a long. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_MEMORY_MB" ]]; then
  if ! [[ "$VIASH_META_MEMORY_MB" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'memory_mb' has to be a long. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_MEMORY_GB" ]]; then
  if ! [[ "$VIASH_META_MEMORY_GB" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'memory_gb' has to be a long. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_MEMORY_TB" ]]; then
  if ! [[ "$VIASH_META_MEMORY_TB" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'memory_tb' has to be a long. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_MEMORY_PB" ]]; then
  if ! [[ "$VIASH_META_MEMORY_PB" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'memory_pb' has to be a long. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi

# create parent directories of output files, if so desired
if [ ! -z "$VIASH_PAR_PREDICTION" ] && [ ! -d "$(dirname "$VIASH_PAR_PREDICTION")" ]; then
  mkdir -p "$(dirname "$VIASH_PAR_PREDICTION")"
fi
if [ ! -z "$VIASH_PAR_SCPLUS_MDATA" ] && [ ! -d "$(dirname "$VIASH_PAR_SCPLUS_MDATA")" ]; then
  mkdir -p "$(dirname "$VIASH_PAR_SCPLUS_MDATA")"
fi
if [ ! -z "$VIASH_PAR_CELL_TOPIC" ] && [ ! -d "$(dirname "$VIASH_PAR_CELL_TOPIC")" ]; then
  mkdir -p "$(dirname "$VIASH_PAR_CELL_TOPIC")"
fi
if [ ! -z "$VIASH_PAR_GRN_EXTENDED" ] && [ ! -d "$(dirname "$VIASH_PAR_GRN_EXTENDED")" ]; then
  mkdir -p "$(dirname "$VIASH_PAR_GRN_EXTENDED")"
fi

# detect volumes from file arguments
VIASH_CHOWN_VARS=()
if [ ! -z "$VIASH_PAR_MULTIOMICS_RNA" ]; then
  VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$VIASH_PAR_MULTIOMICS_RNA")" )
  VIASH_PAR_MULTIOMICS_RNA=$(ViashAutodetectMount "$VIASH_PAR_MULTIOMICS_RNA")
fi
if [ ! -z "$VIASH_PAR_MULTIOMICS_ATAC" ]; then
  VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$VIASH_PAR_MULTIOMICS_ATAC")" )
  VIASH_PAR_MULTIOMICS_ATAC=$(ViashAutodetectMount "$VIASH_PAR_MULTIOMICS_ATAC")
fi
if [ ! -z "$VIASH_PAR_PREDICTION" ]; then
  VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$VIASH_PAR_PREDICTION")" )
  VIASH_PAR_PREDICTION=$(ViashAutodetectMount "$VIASH_PAR_PREDICTION")
  VIASH_CHOWN_VARS+=( "$VIASH_PAR_PREDICTION" )
fi
if [ ! -z "$VIASH_PAR_TF_ALL" ]; then
  VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$VIASH_PAR_TF_ALL")" )
  VIASH_PAR_TF_ALL=$(ViashAutodetectMount "$VIASH_PAR_TF_ALL")
fi
if [ ! -z "$VIASH_PAR_SCPLUS_MDATA" ]; then
  VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$VIASH_PAR_SCPLUS_MDATA")" )
  VIASH_PAR_SCPLUS_MDATA=$(ViashAutodetectMount "$VIASH_PAR_SCPLUS_MDATA")
  VIASH_CHOWN_VARS+=( "$VIASH_PAR_SCPLUS_MDATA" )
fi
if [ ! -z "$VIASH_PAR_CELL_TOPIC" ]; then
  VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$VIASH_PAR_CELL_TOPIC")" )
  VIASH_PAR_CELL_TOPIC=$(ViashAutodetectMount "$VIASH_PAR_CELL_TOPIC")
  VIASH_CHOWN_VARS+=( "$VIASH_PAR_CELL_TOPIC" )
fi
if [ ! -z "$VIASH_PAR_GRN_EXTENDED" ]; then
  VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$VIASH_PAR_GRN_EXTENDED")" )
  VIASH_PAR_GRN_EXTENDED=$(ViashAutodetectMount "$VIASH_PAR_GRN_EXTENDED")
  VIASH_CHOWN_VARS+=( "$VIASH_PAR_GRN_EXTENDED" )
fi
if [ ! -z "$VIASH_META_RESOURCES_DIR" ]; then
  VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$VIASH_META_RESOURCES_DIR")" )
  VIASH_META_RESOURCES_DIR=$(ViashAutodetectMount "$VIASH_META_RESOURCES_DIR")
fi
if [ ! -z "$VIASH_META_EXECUTABLE" ]; then
  VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$VIASH_META_EXECUTABLE")" )
  VIASH_META_EXECUTABLE=$(ViashAutodetectMount "$VIASH_META_EXECUTABLE")
fi
if [ ! -z "$VIASH_META_CONFIG" ]; then
  VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$VIASH_META_CONFIG")" )
  VIASH_META_CONFIG=$(ViashAutodetectMount "$VIASH_META_CONFIG")
fi
if [ ! -z "$VIASH_META_TEMP_DIR" ]; then
  VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$VIASH_META_TEMP_DIR")" )
  VIASH_META_TEMP_DIR=$(ViashAutodetectMount "$VIASH_META_TEMP_DIR")
fi

# get unique mounts
VIASH_UNIQUE_MOUNTS=($(for val in "${VIASH_EXTRA_MOUNTS[@]}"; do echo "$val"; done | sort -u))

# change file ownership
function ViashPerformChown {
  if (( ${#VIASH_CHOWN_VARS[@]} )); then
    set +e
    eval docker run --entrypoint=bash -i --rm ${VIASH_UNIQUE_MOUNTS[@]} ghcr.io/openproblems-bio/task_grn_inference/grn_methods/scenicplus:build-main -c "'chown $(id -u):$(id -g) --silent --recursive ${VIASH_CHOWN_VARS[@]}'"
    set -e
  fi
}
trap ViashPerformChown EXIT

# helper function for filling in extra docker args
VIASH_EXTRA_DOCKER_ARGS=""
if [ ! -z "$VIASH_META_MEMORY_MB" ]; then
  VIASH_EXTRA_DOCKER_ARGS="$VIASH_EXTRA_DOCKER_ARGS --memory=${VIASH_META_MEMORY_MB}m"
fi
if [ ! -z "$VIASH_META_CPUS" ]; then
  VIASH_EXTRA_DOCKER_ARGS="$VIASH_EXTRA_DOCKER_ARGS --cpus=${VIASH_META_CPUS}"
fi


# set dependency paths


ViashDebug "Running command: $(echo docker run --entrypoint=bash -i --rm ${VIASH_UNIQUE_MOUNTS[@]} $VIASH_EXTRA_DOCKER_ARGS ghcr.io/openproblems-bio/task_grn_inference/grn_methods/scenicplus:build-main)"
cat << VIASHEOF | eval docker run --entrypoint=bash -i --rm ${VIASH_UNIQUE_MOUNTS[@]} $VIASH_EXTRA_DOCKER_ARGS ghcr.io/openproblems-bio/task_grn_inference/grn_methods/scenicplus:build-main
set -e
tempscript=\$(mktemp "$VIASH_META_TEMP_DIR/viash-run-scenicplus-XXXXXX").py
function clean_up {
  rm "\$tempscript"
}
function interrupt {
  echo -e "\nCTRL-C Pressed..."
  exit 1
}
trap clean_up EXIT
trap interrupt INT SIGINT
cat > "\$tempscript" << 'VIASHMAIN'
import os
import sys
import yaml
import pickle
import tempfile
import contextlib
import hashlib
import shutil
import requests
import traceback
import subprocess
import gc
import gzip
import tarfile
import shutil
import numpy as np
import scanpy as sc
import pandas as pd
import anndata
import pyranges as pr
import pysam


from urllib.request import urlretrieve


from pycistarget.utils import region_names_to_coordinates
from scenicplus.wrappers.run_pycistarget import run_pycistarget
import polars
import scrublet as scr
from sklearn.manifold import TSNE
import pycisTopic.loom
from pycisTopic.pseudobulk_peak_calling import export_pseudobulk, peak_calling
from pycisTopic.iterative_peak_calling import get_consensus_peaks
from pycisTopic.cistopic_class import create_cistopic_object_from_fragments, merge
from pycisTopic.qc import get_barcodes_passing_qc_for_sample
from pycisTopic.lda_models import evaluate_models, run_cgs_models, run_cgs_models_mallet
from pycisTopic.topic_binarization import binarize_topics
from pycisTopic.topic_qc import compute_topic_metrics, plot_topic_qc, topic_annotation
from pycisTopic.diff_features import impute_accessibility, normalize_scores, find_highly_variable_features, find_diff_features
from pycisTopic.utils import region_names_to_coordinates
from pycisTopic.gene_activity import get_gene_activity
from pycisTopic.loom import export_region_accessibility_to_loom, export_gene_activity_to_loom
from pycisTopic.clust_vis import find_clusters, run_umap, run_tsne, plot_metadata, plot_topic, cell_topic_heatmap

## VIASH START
# The following code has been auto-generated by Viash.
par = {
  'multiomics_rna': $( if [ ! -z ${VIASH_PAR_MULTIOMICS_RNA+x} ]; then echo "r'${VIASH_PAR_MULTIOMICS_RNA//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'multiomics_atac': $( if [ ! -z ${VIASH_PAR_MULTIOMICS_ATAC+x} ]; then echo "r'${VIASH_PAR_MULTIOMICS_ATAC//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'prediction': $( if [ ! -z ${VIASH_PAR_PREDICTION+x} ]; then echo "r'${VIASH_PAR_PREDICTION//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'tf_all': $( if [ ! -z ${VIASH_PAR_TF_ALL+x} ]; then echo "r'${VIASH_PAR_TF_ALL//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'max_n_links': $( if [ ! -z ${VIASH_PAR_MAX_N_LINKS+x} ]; then echo "int(r'${VIASH_PAR_MAX_N_LINKS//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'num_workers': $( if [ ! -z ${VIASH_PAR_NUM_WORKERS+x} ]; then echo "int(r'${VIASH_PAR_NUM_WORKERS//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'temp_dir': $( if [ ! -z ${VIASH_PAR_TEMP_DIR+x} ]; then echo "r'${VIASH_PAR_TEMP_DIR//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'seed': $( if [ ! -z ${VIASH_PAR_SEED+x} ]; then echo "int(r'${VIASH_PAR_SEED//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'cell_type_specific': $( if [ ! -z ${VIASH_PAR_CELL_TYPE_SPECIFIC+x} ]; then echo "r'${VIASH_PAR_CELL_TYPE_SPECIFIC//\'/\'\"\'\"r\'}'.lower() == 'true'"; else echo None; fi ),
  'normalize': $( if [ ! -z ${VIASH_PAR_NORMALIZE+x} ]; then echo "r'${VIASH_PAR_NORMALIZE//\'/\'\"\'\"r\'}'.lower() == 'true'"; else echo None; fi ),
  'only_hvgs': $( if [ ! -z ${VIASH_PAR_ONLY_HVGS+x} ]; then echo "r'${VIASH_PAR_ONLY_HVGS//\'/\'\"\'\"r\'}'.lower() == 'true'"; else echo None; fi ),
  'scplus_mdata': $( if [ ! -z ${VIASH_PAR_SCPLUS_MDATA+x} ]; then echo "r'${VIASH_PAR_SCPLUS_MDATA//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'qc': $( if [ ! -z ${VIASH_PAR_QC+x} ]; then echo "r'${VIASH_PAR_QC//\'/\'\"\'\"r\'}'.lower() == 'true'"; else echo None; fi ),
  'cell_topic': $( if [ ! -z ${VIASH_PAR_CELL_TOPIC+x} ]; then echo "r'${VIASH_PAR_CELL_TOPIC//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'grn_extended': $( if [ ! -z ${VIASH_PAR_GRN_EXTENDED+x} ]; then echo "r'${VIASH_PAR_GRN_EXTENDED//\'/\'\"\'\"r\'}'"; else echo None; fi )
}
meta = {
  'functionality_name': $( if [ ! -z ${VIASH_META_FUNCTIONALITY_NAME+x} ]; then echo "r'${VIASH_META_FUNCTIONALITY_NAME//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'resources_dir': $( if [ ! -z ${VIASH_META_RESOURCES_DIR+x} ]; then echo "r'${VIASH_META_RESOURCES_DIR//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'executable': $( if [ ! -z ${VIASH_META_EXECUTABLE+x} ]; then echo "r'${VIASH_META_EXECUTABLE//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'config': $( if [ ! -z ${VIASH_META_CONFIG+x} ]; then echo "r'${VIASH_META_CONFIG//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'temp_dir': $( if [ ! -z ${VIASH_META_TEMP_DIR+x} ]; then echo "r'${VIASH_META_TEMP_DIR//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'cpus': $( if [ ! -z ${VIASH_META_CPUS+x} ]; then echo "int(r'${VIASH_META_CPUS//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'memory_b': $( if [ ! -z ${VIASH_META_MEMORY_B+x} ]; then echo "int(r'${VIASH_META_MEMORY_B//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'memory_kb': $( if [ ! -z ${VIASH_META_MEMORY_KB+x} ]; then echo "int(r'${VIASH_META_MEMORY_KB//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'memory_mb': $( if [ ! -z ${VIASH_META_MEMORY_MB+x} ]; then echo "int(r'${VIASH_META_MEMORY_MB//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'memory_gb': $( if [ ! -z ${VIASH_META_MEMORY_GB+x} ]; then echo "int(r'${VIASH_META_MEMORY_GB//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'memory_tb': $( if [ ! -z ${VIASH_META_MEMORY_TB+x} ]; then echo "int(r'${VIASH_META_MEMORY_TB//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'memory_pb': $( if [ ! -z ${VIASH_META_MEMORY_PB+x} ]; then echo "int(r'${VIASH_META_MEMORY_PB//\'/\'\"\'\"r\'}')"; else echo None; fi )
}
dep = {
  
}

## VIASH END
# Bug in pycistopic: Import is missing in pycisTopic.loom,
# so TSNE must be dynamically added to the library's namespace.
setattr(pycisTopic.loom, 'TSNE', TSNE)
os.environ['MALLET_MEMORY'] = '200G'

atac_dir = f"{par['temp_dir']}/atac/"
os.makedirs(atac_dir, exist_ok=True)


def process_atac(par):
    print("---Run pre-process started ---", flush=True)
    # Create one individual ATAC-seq file per donor
    adata_atac = anndata.read_h5ad(par['multiomics_atac'])
    unique_donor_ids = [s.replace(' ', '_') for s in adata_atac.obs.donor_id.cat.categories]
    unique_cell_types = [s.replace(' ', '_') for s in adata_atac.obs.cell_type.cat.categories]
    fragments_dict = {}
    for donor_id in unique_donor_ids:
        filepath = os.path.join(atac_dir, f'{donor_id}.tsv')
        if not os.path.exists(filepath):
            print(f'Create tsv file {filepath}')
            adata_atac.obs.cell_type = [s.replace(' ', '_') for s in adata_atac.obs.cell_type]
            adata_atac.obs.donor_id = [s.replace(' ', '_') for s in adata_atac.obs.donor_id]
            adata_atac_one_donor = adata_atac[adata_atac.obs.donor_id == donor_id]
            coo_matrix = adata_atac_one_donor.X.tocoo()
            rows = coo_matrix.row
            cols = coo_matrix.col
            counts = coo_matrix.data
            row_names = adata_atac_one_donor.obs.index[rows]
            coord_names = adata_atac_one_donor.var.index[cols]
            del adata_atac_one_donor
            gc.collect()
            d = {
                'chromosome': np.asarray([s.split(':')[0] for s in coord_names]),
                'start': np.asarray([int(s.split(':')[1].split('-')[0]) for s in coord_names], dtype=np.uint32),
                'end': np.asarray([int(s.split(':')[1].split('-')[1]) for s in coord_names], dtype=np.uint32),
                'barcode': [barcode.replace('-', '') for barcode in row_names],
                'count': np.squeeze(np.asarray(counts.astype(np.uint16)))
            }
            df = pd.DataFrame(d, copy=False)
            df.to_csv(filepath, sep='\\t', index=False, header=False)
        # Compress tsv file
        compressed_filepath = filepath + '.gz'
        if not os.path.exists(compressed_filepath):
            print(f'Sort and compress tsv file {filepath}')
            # Sort file by genomic coordinates
            sorted_filepath = filepath + '.sorted.tsv'
            os.system(f'sort -k1,1 -k2,2n {filepath} > {sorted_filepath}')
            # Compression
            subprocess.run(['bgzip', sorted_filepath, '-o', compressed_filepath])     
            print(f'File compressed and saved as {compressed_filepath}')

        fragments_dict[donor_id] = compressed_filepath

        # # Index file using tabix
        if not os.path.exists(compressed_filepath + '.tbi'): #pip install --user pytabix
            print(f'Index compressed file {compressed_filepath} using tabix')
            subprocess.run(['tabix', compressed_filepath, '-p', 'bed'])
        

    # Collect cell metadata
    print(f'Collect cell metadata')
    adata_atac = anndata.read_h5ad(par['multiomics_atac'])
    donor_ids = [s.replace(' ', '_') for s in adata_atac.obs.donor_id]
    index = [barcode.replace('-', '') + '-' + donor_id for donor_id, barcode in zip(donor_ids, adata_atac.obs.index)]
    cell_data = pd.DataFrame({
        'cell_type': [s.replace(' ', '_') for s in adata_atac.obs.cell_type.to_numpy()],
        'donor_id': [s.replace(' ', '_') for s in adata_atac.obs.donor_id.to_numpy()]
    }, index=index, copy=False)

    # Get chromosome sizes
    print(f'Download chromosome sizes from UCSC')
    chromsizes = pd.read_table(
        'http://hgdownload.cse.ucsc.edu/goldenPath/hg38/bigZips/hg38.chrom.sizes',
        header=None,
        names=['Chromosome', 'End']
    )
    chromsizes.insert(1, 'Start', 0)
    

    print(f'Start pseudobulking')
    os.makedirs(os.path.join(par['temp_dir'], 'consensus_peak_calling'), exist_ok=True)
    os.makedirs(os.path.join(par['temp_dir'], 'consensus_peak_calling/pseudobulk_bed_files'), exist_ok=True)
    os.makedirs(os.path.join(par['temp_dir'], 'consensus_peak_calling/pseudobulk_bw_files'), exist_ok=True)
    os.makedirs(os.path.join(par['temp_dir'], 'consensus_peak_calling/MACS'), exist_ok=True)
    os.makedirs(os.path.join(par['temp_dir'], 'consensus_peak_calling/tmp'), exist_ok=True)

    # Check if individual fragment files are available for each cell type
    valid = True
    bed_paths = {}
    for cell_type in unique_cell_types:
        filepath = os.path.join(par['temp_dir'], 'consensus_peak_calling/pseudobulk_bed_files', f'{cell_type}.fragments.tsv.gz')
        bed_paths[cell_type] = filepath
        if not os.path.exists(filepath):
            valid = False

    # Perform pseudobulking for each cell type
    if not valid:
        print('Pseudobulk each cell type')
        _, bed_paths = export_pseudobulk(
            input_data=cell_data,
            variable='cell_type',
            sample_id_col='donor_id',
            chromsizes=chromsizes,
            bed_path=os.path.join(par['temp_dir'], 'consensus_peak_calling/pseudobulk_bed_files'),
            bigwig_path=os.path.join(par['temp_dir'], 'consensus_peak_calling/pseudobulk_bw_files'),
            path_to_fragments=fragments_dict,
            n_cpu=par['num_workers'],
            temp_dir=os.path.join(par['temp_dir'], 'consensus_peak_calling/tmp'),
            split_pattern='-',
        )
        with open(os.path.join(par['temp_dir'], 'consensus_peak_calling/bed_paths.tsv'), 'wt') as f:
            for v in bed_paths:
                _ = f.write(f'{v}\\t{bed_paths[v]}\\n')

    # Load paths to pseudobulked samples
    bed_paths = {}
    with open(os.path.join(par['temp_dir'], 'consensus_peak_calling/bed_paths.tsv')) as f:
        for line in f:
            v, p = line.strip().split("\\t")
            bed_paths.update({v: p})

    # Call peaks using MACS2
    narrow_peak_dict = peak_calling(
        macs_path = 'macs2',
        bed_paths=bed_paths,
        outdir=os.path.join(os.path.join(par['temp_dir'], 'consensus_peak_calling/MACS')),
        genome_size='hs',
        n_cpu=par['num_workers'],
        input_format='BEDPE',
        shift=73,
        ext_size=146,
        keep_dup='all',
        q_value=0.05
    )

    # Download list of blacklist regions
    if not os.path.exists(os.path.join(par['temp_dir'], 'hg38-blacklist.v2.bed')):
        print('Download list of blacklist regions')
        url = 'https://raw.githubusercontent.com/aertslab/pycisTopic/d6a2f8c832c14faae07def1d3ad8755531f50ad5/blacklist/hg38-blacklist.v2.bed'
        response = requests.get(url)
        with open(os.path.join(par['temp_dir'], 'hg38-blacklist.v2.bed'), 'w') as f:
            f.write(response.text)

    # Consensus peak calling
    consensus_peaks = get_consensus_peaks(
        narrow_peaks_dict=narrow_peak_dict,
        peak_half_width=250,
        chromsizes=chromsizes,
        path_to_blacklist=os.path.join(par['temp_dir'], 'hg38-blacklist.v2.bed')
    )
    consensus_peaks.to_bed(
        path=os.path.join(par['temp_dir'], 'consensus_peak_calling/consensus_regions.bed'),
        keep=True,
        compression='infer',
        chain=False
    )

    # Download TSS annotations
    os.makedirs(os.path.join(par['temp_dir'], 'qc'), exist_ok=True)
    if not os.path.exists(os.path.join(par['temp_dir'], 'qc', 'tss.bed')):
        subprocess.run([
            'pycistopic', 'tss', 'get_tss',
            '--output', os.path.join(par['temp_dir'], 'qc', 'tss.bed'),
            '--name', 'hsapiens_gene_ensembl',
            '--to-chrom-source', 'ucsc',
            '--ucsc', 'hg38'
        ])
    print("---Run pre-process completed ---", flush=True)

def run_cistopic(par):
    if os.path.exists(os.path.join(par['temp_dir'], 'cistopic_obj.pkl')):
        print('Cistopic object exists. Skipping run_cistopic.')
        return 
    print("---Run cistopic---", flush=True)
    if par['qc']:  # Whether to perform quality control
        # Compute QC metrics
        print('Perform QC')
        for donor_id in unique_donor_ids:
            filepath = os.path.join(atac_dir, f'{donor_id}.tsv.gz')
            subprocess.run([
                'pycistopic', 'qc',
                '--fragments', os.path.join(par['temp_dir'], 'qc', 'tss.bed'),
                '--regions', os.path.join(par['temp_dir'], 'consensus_peak_calling/consensus_regions.bed'),
                '--tss', os.path.join(par['temp_dir'], 'qc', 'tss.bed'),
                '--output', os.path.join(par['temp_dir'], 'qc', donor_id),
                '--tss_flank_window', '10000',  # Default: 2000
                '--tss_smoothing_rolling_window', '60',  # Default: 10
                '--tss_minimum_signal_window', '5',  # Default: 100
                '--tss_window', '25',  # Default: 50
                '--tss_min_norm', '0.5',  # Default: 0.2
                '--min_fragments_per_cb', '30',  # Default: 10
                '--threads', '10'
            ])

        # Filter out low quality cells
        print('Filter out low quality cells')
        sample_id_to_barcodes_passing_filters = {}
        sample_id_to_thresholds = {}
        for donor_id in fragments_dict.keys():
            (
                sample_id_to_barcodes_passing_filters[donor_id],
                sample_id_to_thresholds[donor_id]
            ) = get_barcodes_passing_qc_for_sample(
                    sample_id=donor_id,
                    pycistopic_qc_output_dir=os.path.join(par['temp_dir'], 'qc'),
                    unique_fragments_threshold=None, # use automatic thresholding
                    tss_enrichment_threshold=None, # use automatic thresholding
                    frip_threshold=0,
                    use_automatic_thresholds=True,
            )

        # Create cistopic objects
        print('Create cisTopic objects')
        cistopic_obj_list = []
        for donor_id in unique_donor_ids:
            sample_metrics = pl.read_parquet(
                os.path.join(par['temp_dir'], 'qc', donor_id, f'{donor_id}.fragments_stats_per_cb.parquet')
            ).to_pandas().set_index('CB').loc[sample_id_to_barcodes_passing_filters[sample_id]]
            cistopic_obj = create_cistopic_object_from_fragments(
                path_to_fragments=fragments_dict[donor_id],
                path_to_regions=os.path.join(par['temp_dir'], 'consensus_peak_calling/consensus_regions.bed'),
                path_to_blacklist=os.path.join(par['temp_dir'], 'hg38-blacklist.v2.bed'),
                metrics=sample_metrics,
                valid_bc=sample_id_to_barcodes_passing_filters[sample_id],
                n_cpu=par['num_workers'],
                project=donor_id,
                split_pattern='-'
            )
            cistopic_obj_list.append(cistopic_obj)
    else:
        # Skip QC and create cisTopic objects
        print('Create cisTopic objects without QC')
        cistopic_obj_list = []
        for donor_id in unique_donor_ids:
            cistopic_obj = create_cistopic_object_from_fragments(
                path_to_fragments=fragments_dict[donor_id],
                path_to_regions=os.path.join(par['temp_dir'], 'consensus_peak_calling/consensus_regions.bed'),
                path_to_blacklist=os.path.join(par['temp_dir'], 'hg38-blacklist.v2.bed'),
                n_cpu=par['num_workers'],
                project=donor_id,
                split_pattern='-'
            )
            cistopic_obj_list.append(cistopic_obj)

    # Add metadata to cistopic objects
    for i in range(len(cistopic_obj_list)):
        cistopic_obj_list[i].add_cell_data(cell_data, split_pattern='-')

    # Infer doublets using scrublet
    print('Infer doublets using scrublet')
    for i in range(len(cistopic_obj_list)):
        scrub = scr.Scrublet(cistopic_obj_list[i].fragment_matrix.T, expected_doublet_rate=0.1)
        doublet_scores, predicted_doublets = scrub.scrub_doublets()
        scrub.plot_histogram();
        scrub.call_doublets(threshold=0.22)
        scrub.plot_histogram();
        scrublet = pd.DataFrame([scrub.doublet_scores_obs_, scrub.predicted_doublets_], columns=cistopic_obj.cell_names, index=['Doublet_scores_fragments', 'Predicted_doublets_fragments']).T
        cistopic_obj_list[i].add_cell_data(scrublet, split_pattern='-')

    # Combine samples into a single cistopic object
    if len(cistopic_obj_list) == 1:
        cistopic_obj = cistopic_obj_list[0]
    else:
        cistopic_obj = merge(cistopic_obj_list, is_acc=1, copy=False, split_pattern='-')
    
    # Save cistopic objects
    with open(os.path.join(par['temp_dir'], 'cistopic_obj.pkl'), 'wb') as f:
        pickle.dump(cistopic_obj, f)
    # save cell_topic csv 
    cell_topic = cistopic_obj.selected_model.cell_topic.T
    cell_topic.index = cell_topic.index.str.split('-').str[0]
    cell_topic.to_csv(par['cell_topic'])
    
    print("---Run cistopic completed---", flush=True)
     
def run_post_cistopic(par):
    print("---Run post cistopic---", flush=True)
    # Load cistopic objects
    with open(os.path.join(par['temp_dir'], 'cistopic_obj.pkl'), 'rb') as f:
        cistopic_obj = pickle.load(f)
        
    chromsizes = pd.read_table(os.path.join(par['temp_dir'], "qc", "hg38.chrom_sizes_and_alias.tsv"))
    chromsizes.rename({"# ucsc": "Chromosome", "length": "End"}, axis = 1, inplace = True)
    chromsizes['Start'] = 0
    chromsizes = pr.PyRanges(chromsizes[['Chromosome', 'Start', 'End']])

    # Find clusters
    find_clusters(
        cistopic_obj,
        target='cell',
        k=10,
        res=[0.6, 1.2, 3],
        scale=True,
        split_pattern='-'
    )

    # 2D projections
    run_umap(cistopic_obj, target='cell', scale=True)
    run_tsne(cistopic_obj, target='cell', scale=True)

    # Topic binarization
    region_bin_topics_top_3k = binarize_topics(cistopic_obj, method='ntop', ntop=3_000)
    region_bin_topics_otsu = binarize_topics(cistopic_obj, method='otsu')
    binarized_cell_topic = binarize_topics(cistopic_obj, target='cell', method='li')

    # Topic annotation
    topic_annot = topic_annotation(
        cistopic_obj,
        annot_var='cell_type',
        binarized_cell_topic=binarized_cell_topic,
        general_topic_thr=0.2
    )

    # Identify differentially accessible regions
    imputed_acc_obj = impute_accessibility(
        cistopic_obj,
        selected_cells=None,
        selected_regions=None,
        scale_factor=10**6
    )
    normalized_imputed_acc_obj = normalize_scores(imputed_acc_obj, scale_factor=10**4)
    variable_regions = find_highly_variable_features(
        normalized_imputed_acc_obj,
        min_disp=0.05,
        min_mean=0.0125,
        max_mean=3,
        max_disp=np.inf,
        n_bins=20,
        n_top_features=None,
        plot=False
    )
    markers_dict = find_diff_features(
        cistopic_obj,
        imputed_acc_obj,
        variable='cell_type',
        var_features=variable_regions,
        contrasts=None,
        adjpval_thr=0.05,
        log2fc_thr=np.log2(1.5),
        n_cpu=5,
        split_pattern='-'
    )

    # Remove empty markers
    for DAR in list(markers_dict.keys()):
        if len(markers_dict[DAR]) == 0:
            del markers_dict[DAR]

    # Save topics
    folder = os.path.join(par['temp_dir'], 'region_sets', 'Topics_otsu')
    os.makedirs(folder, exist_ok=True)
    for topic in binarized_cell_topic:
        region_names_to_coordinates(
            region_bin_topics_otsu[topic].index
        ).sort_values(
            ['Chromosome', 'Start', 'End']
        ).to_csv(
            os.path.join(folder, f'{topic}.bed'),
            sep='\\t',
            header=False, index=False
        )
    folder = os.path.join(par['temp_dir'], 'region_sets', 'Topics_top_3k')
    os.makedirs(folder, exist_ok=True)
    for topic in region_bin_topics_top_3k:
        region_names_to_coordinates(
            region_bin_topics_top_3k[topic].index
        ).sort_values(
            ['Chromosome', 'Start', 'End']
        ).to_csv(
            os.path.join(folder, f'{topic}.bed'),
            sep='\\t',
            header=False, index=False
        )
    folder = os.path.join(par['temp_dir'], 'candidate_enhancers')
    os.makedirs(folder, exist_ok=True)
    with open(os.path.join(folder, 'region_bin_topics_otsu.pkl'), 'wb') as f:
        pickle.dump(region_bin_topics_otsu, f)
    with open(os.path.join(folder, 'region_bin_topics_top3k.pkl'), 'wb') as f:
        pickle.dump(region_bin_topics_top_3k, f)

    # Save DARs
    folder = os.path.join(par['temp_dir'], 'region_sets', 'DARs_cell_type')
    os.makedirs(folder, exist_ok=True)
    for cell_type in markers_dict:
        region_names_to_coordinates(
            markers_dict[cell_type].index
        ).sort_values(
            ['Chromosome', 'Start', 'End']
        ).to_csv(
            os.path.join(folder, f'{cell_type}.bed'),
            sep='\\t',
            header=False,
            index=False
        )
    folder = os.path.join(par['temp_dir'], 'candidate_enhancers')
    with open(os.path.join(folder, 'markers_dict.pkl'), 'wb') as f:
        pickle.dump(markers_dict, f)
    print("---Run post cistopic completed---", flush=True)


process_atac(par)
run_cistopic(par)
run_post_cistopic(par)
VIASHMAIN
python -B "\$tempscript" &
wait "\$!"

VIASHEOF


# strip viash automount from file paths
if [ ! -z "$VIASH_PAR_MULTIOMICS_RNA" ]; then
  VIASH_PAR_MULTIOMICS_RNA=$(ViashStripAutomount "$VIASH_PAR_MULTIOMICS_RNA")
fi
if [ ! -z "$VIASH_PAR_MULTIOMICS_ATAC" ]; then
  VIASH_PAR_MULTIOMICS_ATAC=$(ViashStripAutomount "$VIASH_PAR_MULTIOMICS_ATAC")
fi
if [ ! -z "$VIASH_PAR_PREDICTION" ]; then
  VIASH_PAR_PREDICTION=$(ViashStripAutomount "$VIASH_PAR_PREDICTION")
fi
if [ ! -z "$VIASH_PAR_TF_ALL" ]; then
  VIASH_PAR_TF_ALL=$(ViashStripAutomount "$VIASH_PAR_TF_ALL")
fi
if [ ! -z "$VIASH_PAR_SCPLUS_MDATA" ]; then
  VIASH_PAR_SCPLUS_MDATA=$(ViashStripAutomount "$VIASH_PAR_SCPLUS_MDATA")
fi
if [ ! -z "$VIASH_PAR_CELL_TOPIC" ]; then
  VIASH_PAR_CELL_TOPIC=$(ViashStripAutomount "$VIASH_PAR_CELL_TOPIC")
fi
if [ ! -z "$VIASH_PAR_GRN_EXTENDED" ]; then
  VIASH_PAR_GRN_EXTENDED=$(ViashStripAutomount "$VIASH_PAR_GRN_EXTENDED")
fi
if [ ! -z "$VIASH_META_RESOURCES_DIR" ]; then
  VIASH_META_RESOURCES_DIR=$(ViashStripAutomount "$VIASH_META_RESOURCES_DIR")
fi
if [ ! -z "$VIASH_META_EXECUTABLE" ]; then
  VIASH_META_EXECUTABLE=$(ViashStripAutomount "$VIASH_META_EXECUTABLE")
fi
if [ ! -z "$VIASH_META_CONFIG" ]; then
  VIASH_META_CONFIG=$(ViashStripAutomount "$VIASH_META_CONFIG")
fi
if [ ! -z "$VIASH_META_TEMP_DIR" ]; then
  VIASH_META_TEMP_DIR=$(ViashStripAutomount "$VIASH_META_TEMP_DIR")
fi


# check whether required files exist
if [ ! -z "$VIASH_PAR_PREDICTION" ] && [ ! -e "$VIASH_PAR_PREDICTION" ]; then
  ViashError "Output file '$VIASH_PAR_PREDICTION' does not exist."
  exit 1
fi
if [ ! -z "$VIASH_PAR_SCPLUS_MDATA" ] && [ ! -e "$VIASH_PAR_SCPLUS_MDATA" ]; then
  ViashError "Output file '$VIASH_PAR_SCPLUS_MDATA' does not exist."
  exit 1
fi
if [ ! -z "$VIASH_PAR_CELL_TOPIC" ] && [ ! -e "$VIASH_PAR_CELL_TOPIC" ]; then
  ViashError "Output file '$VIASH_PAR_CELL_TOPIC' does not exist."
  exit 1
fi
if [ ! -z "$VIASH_PAR_GRN_EXTENDED" ] && [ ! -e "$VIASH_PAR_GRN_EXTENDED" ]; then
  ViashError "Output file '$VIASH_PAR_GRN_EXTENDED' does not exist."
  exit 1
fi


exit 0
